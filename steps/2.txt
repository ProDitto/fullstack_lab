// -- src/lib/api.ts
import { db } from './db';
import type { User } from '../types';
import { v4 as uuidv4 } from 'uuid';

/**
 * Simulates network delay.
 * @param ms - The number of milliseconds to wait.
 */
const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// --- AUTHENTICATION API ---

/**
 * Simulates user registration.
 * @param name - The user's name.
 * @param email - The user's email.
 * @param password - The user's password.
 * @returns The newly created user object.
 * @throws An error if the email is already in use.
 */
export const register = async (name: string, email: string, password: string): Promise<User> => {
  await wait(1000); // Simulate network latency

  const existingUser = await db.users.where('email').equals(email).first();
  if (existingUser) {
    throw new Error('Email already in use.');
  }

  const newUser: User = {
    id: uuidv4(),
    name,
    email,
    passwordHash: password, // In a real app, this would be a securely generated hash.
    avatar: `https://i.pravatar.cc/150?u=${uuidv4()}`,
    isOnline: true,
    createdAt: new Date(),
    friends: [],
  };

  await db.users.add(newUser);
  return newUser;
};

/**
 * Simulates user login.
 * @param email - The user's email.
 * @param password - The user's password.
 * @returns The authenticated user object.
 * @throws An error if the credentials are invalid.
 */
export const login = async (email: string, password: string): Promise<User> => {
  await wait(1000); // Simulate network latency

  const user = await db.users.where('email').equals(email).first();

  if (!user || user.passwordHash !== password) {
    throw new Error('Invalid email or password.');
  }

  // Set user to online
  await db.users.update(user.id, { isOnline: true });
  return { ...user, isOnline: true };
};

/**
 * Simulates a quick login for pre-seeded mock users.
 * @param userId - The ID of the user to log in.
 * @returns The authenticated user object.
 * @throws An error if the user is not found.
 */
export const quickLogin = async (userId: string): Promise<User> => {
  await wait(500); // Faster login for quick login

  const user = await db.users.get(userId);
  if (!user) {
    throw new Error('User not found.');
  }
  
  // Set user to online
  await db.users.update(user.id, { isOnline: true });
  return { ...user, isOnline: true };
};

/**
 * Simulates user logout.
 * @param userId - The ID of the user logging out.
 */
export const logout = async (userId: string): Promise<void> => {
    await wait(500);
    // Set user to offline
    if (userId) {
        await db.users.update(userId, { isOnline: false });
    }
    return;
};


/**
 * Fetches a user profile by ID.
 * @param userId The ID of the user to fetch.
 * @returns The user object.
 */
export const getUserById = async (userId: string): Promise<User | undefined> => {
    await wait(300);
    return db.users.get(userId);
};

// -- src/store/authStore.ts
import create from 'zustand';
import type { User } from '../types';
import * as api from '../lib/api';

interface AuthState {
  currentUser: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  checkSession: () => Promise<void>;
  login: (email: string, password: string) => Promise<void>;
  quickLogin: (userId: string) => Promise<void>;
  register: (name: string, email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  clearError: () => void;
}

export const useAuthStore = create<AuthState>((set, get) => ({
  currentUser: null,
  isAuthenticated: false,
  isLoading: true, // Start with loading true to check session
  error: null,
  
  checkSession: async () => {
    set({ isLoading: true });
    try {
      const userId = sessionStorage.getItem('userId');
      if (userId) {
        const user = await api.getUserById(userId);
        if (user) {
          set({ currentUser: user, isAuthenticated: true, isLoading: false });
        } else {
          sessionStorage.removeItem('userId');
          set({ currentUser: null, isAuthenticated: false, isLoading: false });
        }
      } else {
        set({ isLoading: false });
      }
    } catch (error) {
      console.error("Session check failed:", error);
      set({ currentUser: null, isAuthenticated: false, isLoading: false, error: 'Failed to verify session.' });
    }
  },

  login: async (email, password) => {
    set({ isLoading: true, error: null });
    try {
      const user = await api.login(email, password);
      sessionStorage.setItem('userId', user.id);
      set({ currentUser: user, isAuthenticated: true, isLoading: false });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      set({ isLoading: false, error: errorMessage });
      throw error;
    }
  },

  quickLogin: async (userId: string) => {
    set({ isLoading: true, error: null });
    try {
      const user = await api.quickLogin(userId);
      sessionStorage.setItem('userId', user.id);
      set({ currentUser: user, isAuthenticated: true, isLoading: false });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      set({ isLoading: false, error: errorMessage });
      throw error;
    }
  },

  register: async (name, email, password) => {
    set({ isLoading: true, error: null });
    try {
      const user = await api.register(name, email, password);
      sessionStorage.setItem('userId', user.id);
      set({ currentUser: user, isAuthenticated: true, isLoading: false });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      set({ isLoading: false, error: errorMessage });
      throw error;
    }
  },

  logout: async () => {
    const { currentUser } = get();
    if (currentUser) {
      await api.logout(currentUser.id);
    }
    sessionStorage.removeItem('userId');
    set({ currentUser: null, isAuthenticated: false });
  },

  clearError: () => {
    set({ error: null });
  },
}));

// -- src/hooks/useAuth.ts
import { useAuthStore } from '../store/authStore';

/**
 * Custom hook to provide simplified access to the authentication state and actions
 * from the `useAuthStore`. This is a convenience hook to avoid importing the store
 * directly in components.
 *
 * @returns An object containing the authentication state (`currentUser`, `isAuthenticated`,
 * `isLoading`, `error`) and actions (`login`, `register`, `logout`, etc.).
 */
export const useAuth = () => {
  const authState = useAuthStore();
  return authState;
};

// -- src/components/layout/AuthLayout.tsx
import * as React from 'react';
import { ThemeToggle } from '../ui/ThemeToggle';

interface AuthLayoutProps {
  children: React.ReactNode;
}

/**
 * A simple layout component for authentication pages.
 * It centers the content vertically and horizontally and includes a theme toggle.
 */
export const AuthLayout: React.FC<AuthLayoutProps> = ({ children }) => {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-background-primary p-4">
      <div className="absolute top-4 right-4">
        <ThemeToggle />
      </div>
      <div className="w-full max-w-md">
        {children}
      </div>
    </div>
  );
};

// -- src/components/auth/LoginForm.tsx
import * as React from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { Button } from '@/components/ui/Button';
import { Input } from '@/components/ui/Input';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/Card';
import { useAuth } from '@/hooks/useAuth';
import { Spinner } from '../ui/Spinner';
import { useLiveQuery } from 'dexie-react-hooks';
import { db } from '@/lib/db';
import type { User } from '@/types';

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

type LoginFormValues = z.infer<typeof loginSchema>;

/**
 * Renders the login form, including email/password fields and quick login buttons.
 * Handles form submission, validation, and displays loading/error states.
 */
export const LoginForm: React.FC = () => {
  const { login, quickLogin, isLoading, error, clearError } = useAuth();
  const { register, handleSubmit, formState: { errors } } = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
  });
  
  const quickLoginUsers = useLiveQuery(
    () => db.users.where('email').anyOf('alice@quikchat.dev', 'bob@quikchat.dev', 'charlie@quikchat.dev', 'diana@quikchat.dev').toArray(), []
  ) as User[] | undefined;


  const onSubmit = async (data: LoginFormValues) => {
    try {
        await login(data.email, data.password);
    } catch (err) {
        // Error is handled by the authStore, no need to do anything here
    }
  };
  
  React.useEffect(() => {
    return () => {
      clearError();
    };
  }, [clearError]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Login</CardTitle>
        <CardDescription>Enter your credentials to access your account.</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div className="space-y-1">
            <Input
              id="email"
              placeholder="Email"
              {...register('email')}
              disabled={isLoading}
            />
            {errors.email && <p className="text-sm text-status-error">{errors.email.message}</p>}
          </div>
          <div className="space-y-1">
            <Input
              id="password"
              type="password"
              placeholder="Password"
              {...register('password')}
              disabled={isLoading}
            />
            {errors.password && <p className="text-sm text-status-error">{errors.password.message}</p>}
          </div>
          {error && <p className="text-sm text-status-error text-center">{error}</p>}
          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? <Spinner size="sm" /> : 'Login'}
          </Button>
        </form>
        <div className="mt-4">
          <p className="text-center text-sm text-text-secondary mb-2">Or quick login as:</p>
          <div className="grid grid-cols-2 gap-2">
            {quickLoginUsers?.map(user => (
              <Button key={user.id} variant="outline" onClick={() => quickLogin(user.id)} disabled={isLoading}>
                {user.name}
              </Button>
            ))}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// -- src/components/auth/SignUpForm.tsx
import * as React from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { Button } from '@/components/ui/Button';
import { Input } from '@/components/ui/Input';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/Card';
import { useAuth } from '@/hooks/useAuth';
import { Spinner } from '../ui/Spinner';

const signUpSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
});

type SignUpFormValues = z.infer<typeof signUpSchema>;

/**
 * Renders the sign-up form for new user registration.
 * Handles form submission, validation, and displays loading/error states.
 */
export const SignUpForm: React.FC = () => {
  const { register: registerUser, isLoading, error, clearError } = useAuth();
  const { register, handleSubmit, formState: { errors } } = useForm<SignUpFormValues>({
    resolver: zodResolver(signUpSchema),
  });

  const onSubmit = async (data: SignUpFormValues) => {
    try {
        await registerUser(data.name, data.email, data.password);
    } catch (err) {
        // Error is handled by the authStore
    }
  };
  
  React.useEffect(() => {
    return () => {
      clearError();
    };
  }, [clearError]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Sign Up</CardTitle>
        <CardDescription>Create a new account to start chatting.</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div className="space-y-1">
            <Input
              id="name"
              placeholder="Name"
              {...register('name')}
              disabled={isLoading}
            />
            {errors.name && <p className="text-sm text-status-error">{errors.name.message}</p>}
          </div>
          <div className="space-y-1">
            <Input
              id="email"
              placeholder="Email"
              {...register('email')}
              disabled={isLoading}
            />
            {errors.email && <p className="text-sm text-status-error">{errors.email.message}</p>}
          </div>
          <div className="space-y-1">
            <Input
              id="password"
              type="password"
              placeholder="Password"
              {...register('password')}
              disabled={isLoading}
            />
            {errors.password && <p className="text-sm text-status-error">{errors.password.message}</p>}
          </div>
          {error && <p className="text-sm text-status-error text-center">{error}</p>}
          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? <Spinner size="sm" /> : 'Create Account'}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
};

// -- src/components/auth/AuthPage.tsx
import * as React from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/Tabs';
import { LoginForm } from './LoginForm';
import { SignUpForm } from './SignUpForm';

/**
 * The main authentication page component.
 * It uses tabs to switch between the Login and Sign Up forms.
 */
export const AuthPage: React.FC = () => {
  return (
    <Tabs defaultValue="login" className="w-full">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="login">Login</TabsTrigger>
        <TabsTrigger value="signup">Sign Up</TabsTrigger>
      </TabsList>
      <TabsContent value="login">
        <LoginForm />
      </TabsContent>
      <TabsContent value="signup">
        <SignUpForm />
      </TabsContent>
    </Tabs>
  );
};

// -- src/pages/LoginPage.tsx
import * as React from 'react';
import { AuthLayout } from '@/components/layout/AuthLayout';
import { AuthPage } from '@/components/auth/AuthPage';

/**
 * Renders the login page by wrapping the AuthPage component with the AuthLayout.
 * This is the primary entry point for unauthenticated users.
 */
const LoginPage: React.FC = () => {
  return (
    <AuthLayout>
      <AuthPage />
    </AuthLayout>
  );
};

export default LoginPage;

// -- src/pages/HomePage.tsx
import * as React from 'react';
import { useAuth } from '@/hooks/useAuth';
import { Button } from '@/components/ui/Button';
import { ThemeToggle } from '@/components/ui/ThemeToggle';

/**
 * The main home page for authenticated users.
 * For this step, it serves as a placeholder to demonstrate protected routing.
 */
const HomePage: React.FC = () => {
  const { currentUser, logout } = useAuth();

  return (
    <div className="min-h-screen bg-background-primary text-text-primary p-8">
      <div className="max-w-4xl mx-auto">
        <div className="flex justify-between items-center mb-4">
          <h1 className="text-4xl font-heading">Welcome to QuikChat!</h1>
          <ThemeToggle />
        </div>
        
        {currentUser && (
          <p className="text-lg">
            You are logged in as <span className="font-bold">{currentUser.name}</span>.
          </p>
        )}
        
        <div className="mt-8">
          <Button onClick={logout} variant="destructive">
            Log Out
          </Button>
        </div>
        <p className="mt-4 text-text-secondary">
          (This is the protected home page. More features to come in the next steps!)
        </p>
      </div>
    </div>
  );
};

export default HomePage;

// -- src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, Outlet } from 'react-router-dom';
import { seedDatabase } from './lib/db';
import { useAuthStore } from './store/authStore';
import { Spinner } from './components/ui/Spinner';

// Lazy load pages for better performance
const HomePage = React.lazy(() => import('./pages/HomePage'));
const LoginPage = React.lazy(() => import('./pages/LoginPage'));


/**
 * A component to handle protected routes.
 * If the user is authenticated, it renders the child routes (Outlet).
 * Otherwise, it navigates the user to the login page.
 */
const ProtectedRoute: React.FC = () => {
    const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
    
    // If authenticated, render the nested routes. If not, redirect to login.
    return isAuthenticated ? <Outlet /> : <Navigate to="/login" replace />;
};

/**
 * A component to handle public routes for unauthenticated users.
 * If the user is authenticated, it redirects them to the home page.
 * Otherwise, it renders the child routes (Outlet).
 */
const PublicRoute: React.FC = () => {
    const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

    // If authenticated, redirect to home. If not, render the public route (e.g., login page).
    return isAuthenticated ? <Navigate to="/" replace /> : <Outlet />;
};

/**
 * The main application component.
 * It sets up routing, handles session checking, and displays a loading state
 * while the session is being verified.
 */
const App: React.FC = () => {
  const { checkSession, isLoading } = useAuthStore();

  useEffect(() => {
    // Seed the database on initial load if it's empty.
    seedDatabase().catch(console.error);
    // Check for an existing session.
    checkSession();
  }, [checkSession]);

  // Display a global spinner while checking the session.
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background-primary">
        <Spinner size="lg" />
      </div>
    );
  }

  return (
    <Router>
        <React.Suspense fallback={
            <div className="min-h-screen flex items-center justify-center bg-background-primary">
                <Spinner size="lg" />
            </div>
        }>
            <Routes>
                {/* Routes for unauthenticated users */}
                <Route element={<PublicRoute />}>
                    <Route path="/login" element={<LoginPage />} />
                </Route>

                {/* Routes for authenticated users */}
                <Route element={<ProtectedRoute />}>
                    <Route path="/" element={<HomePage />} />
                    {/* Add other protected routes here in the future */}
                </Route>
                
                {/* Fallback route - if no other route matches */}
                <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
        </React.Suspense>
    </Router>
  );
};

export default App;