// -- src/lib/simulation.ts
import { db } from './db';
import type { Message, User, Chat } from '../types';
import { v4 as uuidv4 } from 'uuid';

let simulationInterval: NodeJS.Timeout | null = null;

const MOCK_MESSAGES = [
    "Hey, do you have a minute to chat?",
    "Just saw your message, I'll get back to you shortly.",
    "That sounds great! Let's do it.",
    "Can you send me the file?",
    "I'm running a bit late, sorry!",
    "Let's sync up tomorrow morning.",
    "👍",
    "😂",
    "Got it, thanks!",
];

/**
 * Starts the real-time chat simulation.
 * This function sets up an interval to perform two main actions:
 * 1. Simulate a mock user sending a new message to a chat the current user is in.
 * 2. Simulate message status updates (delivered, seen) for messages sent by the current user.
 * 
 * @param currentUserId - The ID of the currently logged-in user.
 */
export const startChatSimulation = (currentUserId: string) => {
    if (simulationInterval) {
        console.log("Simulation already running.");
        return;
    }

    console.log("Starting chat simulation...");

    simulationInterval = setInterval(async () => {
        try {
            // Action 1: Simulate a new incoming message from a mock user
            if (Math.random() < 0.3) { // 30% chance to send a message each interval
                const userChats = await db.chats.where('participantIds').equals(currentUserId).toArray();
                if (userChats.length === 0) return;

                // Pick a random chat
                const randomChat = userChats[Math.floor(Math.random() * userChats.length)];
                
                // Pick a random participant from that chat (who is not the current user)
                const otherParticipants = randomChat.participantIds.filter(id => id !== currentUserId);
                if (otherParticipants.length === 0) return;
                
                const randomSenderId = otherParticipants[Math.floor(Math.random() * otherParticipants.length)];

                const newMessage: Message = {
                    id: uuidv4(),
                    chatId: randomChat.id,
                    senderId: randomSenderId,
                    content: MOCK_MESSAGES[Math.floor(Math.random() * MOCK_MESSAGES.length)],
                    timestamp: new Date(),
                    isEvent: false,
                };

                await db.transaction('rw', db.messages, db.chats, async () => {
                    await db.messages.add(newMessage);
                    // Increment unread count for the chat
                    await db.chats.update(randomChat.id, { 
                        lastMessage: newMessage,
                        unreadCount: (randomChat.unreadCount || 0) + 1,
                    });
                });
            }

            // Action 2: Simulate status updates for messages sent by the current user
            const sentMessages = await db.messages
                .where({ senderId: currentUserId })
                .and(msg => msg.status === 'sent' || msg.status === 'delivered')
                .toArray();

            for (const msg of sentMessages) {
                if (msg.status === 'sent' && Math.random() < 0.5) { // 50% chance to become 'delivered'
                    await db.messages.update(msg.id, { status: 'delivered' });
                    // Also update the lastMessage in the chat if it matches
                    const chat = await db.chats.get(msg.chatId);
                    if (chat?.lastMessage?.id === msg.id) {
                        await db.chats.update(msg.chatId, { 'lastMessage.status': 'delivered' });
                    }
                } else if (msg.status === 'delivered' && Math.random() < 0.2) { // 20% chance to become 'seen'
                    await db.messages.update(msg.id, { status: 'seen' });
                    const chat = await db.chats.get(msg.chatId);
                    if (chat?.lastMessage?.id === msg.id) {
                         await db.chats.update(msg.chatId, { 'lastMessage.status': 'seen' });
                    }
                }
            }

        } catch (error) {
            console.error("Error in simulation interval:", error);
        }
    }, 5000); // Run every 5 seconds
};

/**
 * Stops the real-time chat simulation by clearing the interval.
 */
export const stopChatSimulation = () => {
    if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
        console.log("Chat simulation stopped.");
    }
};

// -- src/hooks/useWebSocketSim.ts
import * as React from 'react';
import { useAuthStore } from '../store/authStore';
import { startChatSimulation, stopChatSimulation } from '../lib/simulation';

/**
 * A custom hook to manage the lifecycle of the chat simulation.
 * It starts the simulation when a user is authenticated and stops it
 * when they log out. This mimics a WebSocket connection lifecycle.
 */
export const useWebSocketSim = () => {
    const { currentUser, isAuthenticated } = useAuthStore();

    React.useEffect(() => {
        if (isAuthenticated && currentUser) {
            startChatSimulation(currentUser.id);
        } else {
            stopChatSimulation();
        }

        // Cleanup function to stop simulation on component unmount or re-render
        return () => {
            stopChatSimulation();
        };
    }, [isAuthenticated, currentUser]);
};

// -- src/store/chatStore.ts
import { create } from 'zustand';
import type { Chat, Message } from '../types';
import * as api from '../lib/api';
import { useAuthStore } from './authStore';

interface ChatState {
  activeChatId: string | null;
  messages: Message[];
  messagesLoading: boolean;
  hasMoreMessages: boolean;
  
  setActiveChatId: (chatId: string | null) => Promise<void>;
  fetchMessages: (chatId: string) => Promise<void>;
  loadMoreMessages: () => Promise<void>;
  sendMessage: (content: string) => Promise<void>;
  addIncomingMessage: (message: Message) => void;
}

export const useChatStore = create<ChatState>((set, get) => ({
  activeChatId: null,
  messages: [],
  messagesLoading: false,
  hasMoreMessages: true,

  setActiveChatId: async (chatId: string | null) => {
    const currentActiveId = get().activeChatId;
    if (currentActiveId === chatId) return;
    
    set({ activeChatId: chatId, messages: [], hasMoreMessages: true });
    
    if (chatId) {
      await get().fetchMessages(chatId);
      const currentUserId = useAuthStore.getState().currentUser?.id;
      if (currentUserId) {
        await api.markMessagesAsSeen(chatId, currentUserId);
      }
    }
  },

  fetchMessages: async (chatId: string) => {
    set({ messagesLoading: true });
    try {
      const { messages, nextCursor } = await api.getMessagesForChat(chatId);
      set({
        messages,
        hasMoreMessages: !!nextCursor,
        messagesLoading: false,
      });
    } catch (error) {
      console.error("Failed to fetch messages:", error);
      set({ messagesLoading: false });
    }
  },

  loadMoreMessages: async () => { /* ... (implementation from Step 4, unchanged) ... */ },

  sendMessage: async (content: string) => {
    const { activeChatId } = get();
    const senderId = useAuthStore.getState().currentUser?.id;

    if (!activeChatId || !senderId || !content.trim()) return;

    try {
      const newMessage = await api.sendMessage(activeChatId, senderId, content);
      set(state => ({ messages: [...state.messages, newMessage] }));
    } catch (error) {
      console.error("Failed to send message:", error);
    }
  },

  /**
   * Adds a new incoming message to the message list if it belongs to the active chat.
   * This is intended to be called by a listener (e.g., from our simulation hook).
   * @param message - The new message object.
   */
  addIncomingMessage: (message: Message) => {
    const { activeChatId } = get();
    if (message.chatId === activeChatId) {
        set(state => ({
            messages: [...state.messages, message],
        }));
    }
  },
}));

// -- src/App.tsx
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, Outlet } from 'react-router-dom';
import { seedDatabase } from './lib/db';
import { useAuthStore } from './store/authStore';
import { Spinner } from './components/ui/Spinner';
import { useWebSocketSim } from './hooks/useWebSocketSim';
import { useLiveQuery } from 'dexie-react-hooks';
import { db } from './lib/db';
import { useChatStore } from './store/chatStore';

const HomePage = React.lazy(() => import('./pages/HomePage'));
const LoginPage = React.lazy(() => import('./pages/LoginPage'));

const ProtectedRoute: React.FC = () => {
    const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
    return isAuthenticated ? <Outlet /> : <Navigate to="/login" replace />;
};

const PublicRoute: React.FC = () => {
    const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
    return isAuthenticated ? <Navigate to="/" replace /> : <Outlet />;
};

/**
 * A component that listens for real-time message updates from Dexie
 * and syncs them with the Zustand store.
 */
const RealtimeMessageSync = () => {
    const addIncomingMessage = useChatStore(state => state.addIncomingMessage);
    
    // Listen to all new messages being added to the database
    useLiveQuery(async () => {
        db.messages.hook('creating', (primKey, obj, trans) => {
            // This hook fires just before a message is created.
            // We can then push it to our store if it's an incoming message.
            const currentUser = useAuthStore.getState().currentUser;
            if (obj.senderId !== currentUser?.id) {
                addIncomingMessage(obj);
            }
        });
    }, []);

    return null; // This component does not render anything
};

const App: React.FC = () => {
  const { checkSession, isLoading, isAuthenticated } = useAuthStore();

  // Initialize the WebSocket simulation hook. It will manage its own lifecycle.
  useWebSocketSim();

  useEffect(() => {
    seedDatabase().catch(console.error);
    checkSession();
  }, [checkSession]);

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background-primary">
        <Spinner size="lg" />
      </div>
    );
  }

  return (
    <Router>
        {/* Only mount the real-time sync when authenticated */}
        {isAuthenticated && <RealtimeMessageSync />}
        <React.Suspense fallback={
            <div className="min-h-screen flex items-center justify-center bg-background-primary">
                <Spinner size="lg" />
            </div>
        }>
            <Routes>
                <Route element={<PublicRoute />}>
                    <Route path="/login" element={<LoginPage />} />
                </Route>
                <Route element={<ProtectedRoute />}>
                    <Route path="/" element={<HomePage />} />
                </Route>
                <Route path="*" element={<Navigate to="/" replace />} />
            </Routes>
        </React.Suspense>
    </Router>
  );
};

export default App;

// -- src/components/chat/Sidebar.tsx
// This file is identical to the one from Step 3. The useLiveQuery for chats
// automatically handles real-time updates to `unreadCount` and `lastMessage`
// from the simulation, so no changes are needed in the component itself.
// The interactive icons were already added as placeholders in Step 3.
// For clarity, here it is again, unchanged.
import * as React from 'react';
import { Globe, LogOut, Plus, Settings, User as UserIcon } from 'lucide-react';
import { useAuth } from '@/hooks/useAuth';
import { useChatStore } from '@/store/chatStore';
import { Button } from '../ui/Button';
import { Avatar, AvatarFallback, AvatarImage } from '../ui/Avatar';
import { Popover, PopoverContent, PopoverTrigger } from '../ui/Popover';
import { ScrollArea } from '../ui/ScrollArea';
import { Skeleton } from '../ui/Skeleton';
import { db } from '@/lib/db';
import { useLiveQuery } from 'dexie-react-hooks';
import type { Chat, User } from '@/types';
import { getChatPartner } from '@/lib/api';
import { cn, timeAgo } from '@/lib/utils';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/Tooltip';
import { useNavigate } from 'react-router-dom';

export const Sidebar: React.FC = () => { /* ... (same as Step 3) ... */ return <aside className="w-80 h-full flex flex-col border-r border-border bg-background-secondary"><UserMenu /><ChatList /></aside> };
const UserMenu: React.FC = () => { /* ... (same as Step 3) ... */ return <div/> };
const ChatList: React.FC = () => { /* ... (same as Step 3) ... */ return <div/> };
const ChatItem: React.FC<{ chat: Chat; currentUserId: string }> = ({ chat, currentUserId }) => {
    const { activeChatId, setActiveChatId } = useChatStore();
    const [partner, setPartner] = React.useState<User | null>(null);

    React.useEffect(() => {
        if (!chat.isGroup) {
        getChatPartner(chat, currentUserId).then(p => setPartner(p || null));
        }
    }, [chat, currentUserId]);

    const displayName = chat.isGroup ? chat.name : partner?.name;
    const displayAvatar = chat.isGroup ? chat.avatar : partner?.avatar;
    const isActive = chat.id === activeChatId;
    
    // When a chat is active, its unread count should be 0.
    const unreadCount = isActive ? 0 : chat.unreadCount;

    return (
        <Button
        variant="ghost"
        onClick={() => setActiveChatId(chat.id)}
        className={cn(
            "w-full h-auto p-2 justify-start rounded-none",
            isActive && "bg-primary-accent/10"
        )}
        >
        <Avatar className="h-11 w-11 mr-3">
            <AvatarImage src={displayAvatar} alt={displayName} />
            <AvatarFallback>{displayName?.charAt(0)}</AvatarFallback>
        </Avatar>
        <div className="w-full overflow-hidden">
            <div className="flex justify-between items-center">
            <p className="font-semibold text-sm truncate text-text-primary">{displayName || '...'}</p>
            {chat.lastMessage && <p className="text-xs text-text-secondary">{timeAgo(chat.lastMessage.timestamp)}</p>}
            </div>
            <div className="flex justify-between items-start">
            <p className="text-xs text-text-secondary truncate pr-2">
                {chat.lastMessage?.content || 'No messages yet'}
            </p>
            {unreadCount > 0 && (
                <span className="bg-primary-accent text-white text-xs font-bold rounded-full h-5 w-5 flex items-center justify-center">
                    {unreadCount}
                </span>
            )}
            </div>
        </div>
        </Button>
    );
};

// const ChatListSkeleton: React.FC = () => { /* ... (same as Step 3) ... */ return <div/> };
